"use strict";(self.webpackChunkWebComponents=self.webpackChunkWebComponents||[]).push([[780],{34630:(e,t,r)=>{function n(e){for(const[t,r]of(e=>{const t=new Set;do{for(const r of Reflect.ownKeys(e))t.add([e,r])}while((e=Reflect.getPrototypeOf(e))&&e!==Object.prototype);return t})(e.constructor.prototype)){if("constructor"===r)continue;const n=Reflect.getOwnPropertyDescriptor(t,r);n&&"function"==typeof n.value&&(e[r]=e[r].bind(e))}}r.d(t,{c:()=>n})},64617:()=>{navigator.permissions||"function"!=typeof DeviceMotionEvent.requestPermission||"function"!=typeof DeviceOrientationEvent.requestPermission||(navigator.permissions={query:e=>{switch(e.name){case"accelerometer":case"gyroscope":return new Promise(((e,t)=>{Promise.all([DeviceMotionEvent.requestPermission(),DeviceOrientationEvent.requestPermission()]).then((t=>e({state:t.every((e=>"granted"===e))?"granted":"denied"})))}));default:return Promise.resolve({state:"granted"})}}})},28660:()=>{function e(e,t){for(const r in t)Object.defineProperty(e,r,{configurable:!0,value:t[r]})}Symbol("__sensor__");const t=(t,...r)=>class extends t{constructor(...t){super(t);const r=document.createDocumentFragment();this.addEventListener=(e,...t)=>r.addEventListener(e,...t),this.removeEventListener=(...e)=>r.removeEventListener(...e),this.dispatchEvent=t=>{e(t,{currentTarget:this}),t.target||e(t,{target:this});const n=`on${t.type}`;"function"==typeof this[n]&&this[n](t);const s=r.dispatchEvent(t);return s&&this.parentNode&&this.parentNode.dispatchEvent(t),e(t,{currentTarget:null,target:null}),s}}};class r extends(t(Object)){}class n extends Event{constructor(e,t){if(super(e,t),!(t&&t.error instanceof DOMException))throw TypeError("Failed to construct 'SensorErrorEvent':2nd argument much contain 'error' property");Object.defineProperty(this,"error",{configurable:!1,writable:!1,value:t.error})}}},55780:(e,t,r)=>{r.r(t),r.d(t,{SimpleAbsoluteOrientationSensor:()=>g,SimpleAccelerometer:()=>d,SimpleAmbientLightSensor:()=>l,SimpleGeolocationSensor:()=>u,SimpleGravitySensor:()=>m,SimpleGyroscope:()=>h,SimpleLinearAccelerationSensor:()=>p,SimpleMagnetometer:()=>v,SimpleRelativeOrientationSensor:()=>y}),r(64617),r(28660);let n;window.GeolocationSensor||Sensor,screen.orientation?n=screen.orientation:screen.msOrientation?n=screen.msOrientation:(n={},Object.defineProperty(n,"angle",{get:()=>window.orientation||0}));const s=(e,...t)=>class extends e{constructor(...e){super(e);for(const e of t)if(`on${e}`in window){this[slot].eventName=e;break}this[slot].activateCallback=()=>{window.addEventListener(this[slot].eventName,this[slot].handleEvent,{capture:!0})},this[slot].deactivateCallback=()=>{window.removeEventListener(this[slot].eventName,this[slot].handleEvent,{capture:!0})}}};window.RelativeOrientationSensor||s(Sensor,"deviceorientation"),window.AbsoluteOrientationSensor||s(Sensor,"deviceorientationabsolute","deviceorientation"),window.Gyroscope||s(Sensor,"devicemotion"),window.Accelerometer||s(Sensor,"devicemotion"),window.LinearAccelerationSensor||s(Sensor,"devicemotion"),window.GravitySensor||s(Sensor,"devicemotion");var o=r(34630);class i{constructor(){(0,o.c)(this),this.sensor=null}async start(e,t,r){if(this.sensor)throw"In use. Stop the sensor before starting another.";if("function"!=typeof e)throw"Not available.";if(navigator.permissions&&!(await Promise.all(t.map((e=>navigator.permissions.query({name:e}))))).every((e=>"granted"===e.state)))throw`Permission to use the ${t} sensor was denied.`;let n,s;this.sensor=null;let o=new Promise(((t,o)=>{try{this.sensor=new e(r);let i=this;n=e=>{i.sensor.removeEventListener("error",n),"NotAllowedError"===e.error.name?o("Access to this sensor is not allowed."):"NotReadableError"===e.error.name&&o("Cannot connect to the sensor."),o(`Unknown error: ${e.error.name}`)},this.sensor.addEventListener("error",n),s=e=>{i.sensor.removeEventListener("reading",s),t()},this.sensor.addEventListener("reading",s),this.sensor.start()}catch(e){"SecurityError"===e.name?o("Sensor construction was blocked by a feature policy."):"ReferenceError"===e.name?o("Sensor is not supported by the User Agent."):o(e)}}));try{console.log(`Await ${new Date}`),await o}catch(e){throw this.stop(),e}finally{console.log(`Done ${new Date}`),this.sensor.removeEventListener("error",n),this.sensor.removeEventListener("reading",s)}}get ready(){return this.sensor&&this.sensor.activated&&this.sensor.hasReading}stop(){this.sensor&&this.sensor.stop(),this.sensor=null}}class a extends i{get x(){return this.sensor.x}get y(){return this.sensor.y}get z(){return this.sensor.z}}class c extends i{get quaternion(){return this.sensor.quaternion}populateMatrix(e){return this.sensor.populateMatrix(e)}}class l extends i{async start(e){return super.start(window.AmbientLightSensor,["ambient-light-sensor"],e)}get illuminance(){return this.sensor.illuminance}}class u extends i{async start(e){return super.start(GeolocationSensor,["geolocation"],e)}get latitude(){return this.sensor.latitude}get longitude(){return this.sensor.longitude}get altitude(){return this.sensor.altitude}get accuracy(){return this.sensor.accuracy}get altitudeAccuracy(){return this.sensor.altitudeAccuracy}get heading(){return this.sensor.heading}get speed(){return this.sensor.speed}}class d extends a{async start(e){return super.start(Accelerometer,["accelerometer"],e)}}class h extends a{async start(e){return super.start(Gyroscope,["gyroscope"],e)}}class p extends a{async start(e){return super.start(LinearAccelerationSensor,["accelerometer"],e)}}class m extends a{async start(e){return super.start(GravitySensor,["accelerometer"],e)}}class v extends a{async start(e){return super.start(window.Magnetometer,["magnetometer"],e)}}class g extends c{async start(e){return super.start(AbsoluteOrientationSensor,["accelerometer","gyroscope","magnetometer"],e)}}class y extends c{async start(e){return super.start(RelativeOrientationSensor,["accelerometer","gyroscope"],e)}}}}]);
//# sourceMappingURL=780.831c13887278a5a7.bundle.js.map